<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>html5经典tank大战</title>
   <script src="tank.js"></script>
  <style type="text/css">
    #tankMap1{
      position: absolute;
      margin-left: 50px;
      margin-top: 100px;
    }
    #heroMap2
    {
      position: absolute;
      margin-left: 50px;
      margin-top: 100px;
    }
    #heroMap3
     {
       position: absolute;
       margin-left: 50px;
       margin-top: 300px;
      width:500px;
      background-color: #00b0e8;
      display:none;
      background-image:linear-gradient(to top left, #fff,blue,yellow,red)
     }
    #heroMap3 h1{
      height:200px;
      line-height: 200px;
      color:darkred;
      text-shadow: 5px 5px 5px 5px yellow;
    }
   </style>
</head>
<body onkeydown="test()">
<canvas id="tankMap1" width="500px" height="600px" style="background-color:black" ></canvas>
<canvas id="heroMap2" width="500px" height="600px" style="background-color:transparent" ></canvas>
<div id="heroMap3"  style="text-align: center" ><h1>Congratulation,You have won!</h1></div>
<span id="aa">数据</span><br/><span id="ab">数据</span><br/><span id="ac">数据</span><br/><span id="ad">数据</span><br/><span id="ae">数据</span>
<script type="text/javascript">
  var drawing=document.getElementById("tankMap1");
  var cxt=drawing.getContext('2d');
  var drawing2=document.getElementById("heroMap2");
  var cxt2=drawing2.getContext('2d');

 // cxt3.globalAlpha=0.7;
  //我的坦克
  //定义hero类

  var hero=new Hero(280,360,3,5,"hero");//全局变量
  //2、画出敌人坦克思路：a：敌人坦克做成对象-->定义EnergyTank；都是坦克，可以继承一个Tank类，因此
  // 可以抽象出一个父类，把Hero类和Energy类共有的特点系在Tank类中b：敌人坦克在作战区

  //把绘制函数封装成一个函数，将来可以作为成员函数
  //将来这函数可以画自己的坦克，也可以画敌人的坦克
  //tank是一个对象
//定义敌人的坦克(是单个单个的定义还是放在数组中)


  //定义敌人的坦克(敌人的坦克有多少? 思路 : 是单个单个的定义，还是放在数组中?)
  var enemyTanks=new Array();

  //定义敌人子弹的数组

  var enemyBullets=new Array();


  //定义一个炸弹数组(可以存放很多炸弹,)

  var bombs=new Array();
  //先死后活 ，定3个，后面我们把敌人坦克的数量，作出变量
  //0->上, 1->右, 2->下 3->左
/*  for(var i=0;i<3;i++){

    //创建一个坦克
    var enemyTank=new EnemyTank((i+1)*50,0,2,enmeyColor);
    //把这个坦克放入数组
    enemyTanks[i]=enemyTank;

    //启动这个敌人的坦克
    window.setInterval("enemyTanks["+i+"].run()",50);

    //当创建敌人坦克时就分配子弹
    var eb=new Bullet(enemyTanks[i].x+9,enemyTanks[i].y+30,2,1.2,"enemy",enemyTanks[i]);

    enemyBullets[i]=eb;
    //启动该子弹
    var ettimer=window.setInterval("enemyBullets["+i+"].run()",50);
    enemyBullets[i].timer=ettimer;

  }*/
 /* var enemy_x=(Math.random()*490);
  var enemy_y=Math.random()*300;*/
/*  var enemy_direct=Math.round(Math.random()*3);*/
  for(var i=0;i<5;i++){
    var enemy_x=(Math.random()*490);
    var enemy_y=Math.random()*350;
    var enemy_direct=Math.round(Math.random()*3);
 /*   var enemyTank=new EnemyTank((i+1)*50,20,2,2,"enemy");*/
    var enemyTank=new EnemyTank(enemy_x,enemy_y,enemy_direct,32,"enemy");
    enemyTanks[i]=enemyTank;

    //启动这个敌人的坦克
    window.setInterval("enemyTanks["+i+"].run()",50);
    //当创建敌人坦克时就分配子弹c

    if(enemyTanks[i].isLive==true){
      switch(enemyTanks[i].direct){
        case 0:
          var eb=new Bullet(enemyTanks[i].x+9,enemyTanks[i].y,enemyTanks[i].direct,2,"enemy",enemyTanks[i]);
          break;
        case 1:
          var eb=new Bullet(enemyTanks[i].x+30,enemyTanks[i].y+9,enemyTanks[i].direct,2,"enemy",enemyTanks[i]);
          break;
        case 2:
          var eb=new Bullet(enemyTanks[i].x+9,enemyTanks[i].y+30,enemyTanks[i].direct,2,"enemy",enemyTanks[i]);
          break;
        case 3: //右
          var eb=new Bullet(enemyTanks[i].x,enemyTanks[i].y+9,enemyTanks[i].direct,2,"enemy",enemyTanks[i]);
          break;
      }
    }



    enemyBullets[i]=eb;
    //启动该子弹
    var ettimer=window.setInterval("enemyBullets["+i+"].run()",50);
    enemyBullets[i].timer=ettimer;

    //画出这个坦克
    drawTank(enemyTanks[i]);
  }
  flashTanMap();
  //专门写一个函数，用于定时刷新作战区，把要在作战区出现的对象

/*  check();*/
  function  flashTanMap() {
    cxt.clearRect(0,0,500,600);
    //画墙
    drawWall();
    //画神
    drawGod();
    if(hero.isLive==false||god.isLive==false){
      alert("You have Lost");
      window.clearInterval(timer1);
    }
    if(enemyTanks[0].isLive==false&&enemyTanks[1].isLive==false&&enemyTanks[2].isLive==false&&enemyTanks[3].isLive==false&&enemyTanks[4].isLive==false){
      document.getElementById("heroMap3").style.display="block";
    }


    drawTank(hero);
    //画出子弹
    for(var i=0;i<enemyTanks.length;i++) {
      if (enemyTanks[i].bulletIsLive == false) {
        enemyTanks[i].bulletIsLive = true;
     /*   console.log(enemyTanks[i].isLive);*/
        if(enemyTanks[i].isLive==true){
          switch(enemyTanks[i].direct){
            case 0:
              enemyBullets[i]=new Bullet(enemyTanks[i].x+9,enemyTanks[i].y,enemyTanks[i].direct,2,"enemy",enemyTanks[i]);
              break;
            case 1:
              enemyBullets[i]=new Bullet(enemyTanks[i].x+30,enemyTanks[i].y+9,enemyTanks[i].direct,2,"enemy",enemyTanks[i]);
              break;
            case 2:
              enemyBullets[i]=new Bullet(enemyTanks[i].x+9,enemyTanks[i].y+30,enemyTanks[i].direct,2,"enemy",enemyTanks[i]);
              break;
            case 3: //右
              enemyBullets[i]=new Bullet(enemyTanks[i].x,enemyTanks[i].y+9,enemyTanks[i].direct,2,"enemy",enemyTanks[i]);
              break;
          }
        }


        var ettimer = window.setInterval("enemyBullets[" + i + "].run()", 50);

        enemyBullets[i].timer = ettimer;

        drawEnemyBullet(enemyTanks[i], i,enemyBullets[i]);

      }
      else {

        drawEnemyBullet(enemyTanks[i], i,enemyBullets[i]);
      }
    }
   /* for(var i=0;i<enemyTanks.length;i++){
      drawEnemyBullet(enemyTanks[i], i);
    }*/
    /*drawEnemyBullet();*/
    document.getElementById("aa").innerText="子弹x="+enemyBullets[1].x+" 子弹y="+enemyBullets[1].y;
    document.getElementById("ab").innerText="子弹x="+enemyBullets[2].x+" 子弹y="+enemyBullets[2].y;
    document.getElementById("ac").innerText="子弹x="+enemyBullets[3].x+" 子弹y="+enemyBullets[3].y;
    document.getElementById("ad").innerText="子弹x="+enemyBullets[4].x+" 子弹y="+enemyBullets[4].y;
    document.getElementById("ae").innerText="子弹x="+enemyBullets[0].x+" 子弹y="+enemyBullets[0].y;


  /*  for(var i=0;i<5;i++){
		 if(enemyBullets[i].x<0||enemyBullets[i].x>250||enemyBullets[i].y<10||enemyBullets[i].y>300){
		  enemyBullets[i]=new Bullet(enemyTanks[i].x+9,enemyTanks[i].y+30,2,1.2,"enemy",enemyTanks[i]);
		  var ettimer=window.setInterval("enemyBullets["+i+"].run()",50);
    enemyBullets[i].timer=ettimer;
               drawEnemyBullet(enemyTanks[i],i);

	  		 }else
		{
		drawEnemyBullet(enemyTanks[i],i);
		}
    }*/
    isHitEnemyTank();
    for(var i=0;i<enemyTanks.length;i++){
      isHitHreoTank(enemyBullets[i]);
    }
    drawEnemyBomb();

    //画出所有敌人坦克
    for(var i=0;i<5;i++){
      drawTank(enemyTanks[i]);
    }

  }
  function flashBullet() {
    cxt2.globalAlpha=1;
    cxt2.clearRect(0,0,500,600);
    drawHeroBullet();
  }
   function test(evt) {
    evt = (evt) ? evt : ((window.event) ? window.event : "");//火狐window对象没有event属性，所以window.event是不存在的，Firefox只能在事件句柄函数的第一个参数获取事件对象。
    var code = evt.keyCode?evt.which:evt.keyCode;
    switch(code){
      case 65:
       // hero.x=hero.x-hero.speed;//不是面向对象
              var flag=null;
   for (var i = 0; i < wall.length; i++) {
          if ((hero.x-20 > 0) && (hero.y+30 > wall[i].y) && (hero.y < (wall[i].y + 40)) && ((hero.x - hero.speed) >= wall[i].x) && ((hero.x - hero.speed) < (wall[i].x + 40))&&(wall[i].isLive==true)){
            flag = 1;
          }
        }
        if((hero.x-hero.speed)>0&&flag!=1){
          hero.moveLeft();
        }
        break;
      case 83:
       // hero.y=hero.y+hero.speed;
        for(var i=0;i<wall.length;i++){
          if ((hero.y+30<600) && ((hero.y+30 + hero.speed)>= wall[i].y) &&(hero.y+30 + hero.speed) < (wall[i].y + 40) && (hero.x+20 >= wall[i].x) &&( hero.x < wall[i].x + 40)&&(wall[i].isLive==true)){
                  flag = 1;
                }
              }
           if((hero.y+hero.speed)<600&&flag!=1){
             hero.moveDown();
           }
        break;
      case 68:
        //hero.x=hero.x+hero.speed;
          /*    console.log((hero.x + hero.speed),wall[2].x, ((hero.x + hero.speed) >= wall[2].x));*/
        /*console.log((hero.x-20 > 0) , (hero.y+30 > wall[2].y) , (hero.y < (wall[2].y + 40)) , ((hero.x - hero.speed) >= wall[2].x) , ((hero.x - hero.speed) < (wall[2].x + 40)),(wall[2].isLive==true));*/
        for (var i = 0; i < wall.length; i++) {
          if ((hero.x+20 <500) && (hero.y+30 > wall[i].y) && (hero.y < (wall[i].y + 40)) && ((hero.x+30 + hero.speed) >= wall[i].x) && ((hero.x + hero.speed) < (wall[i].x + 40))&&(wall[i].isLive==true)){
            flag = 1;
          }
        }
        if((hero.x+hero.speed)<500&&flag!=1){
          hero.moveRight();
        }
        break;
      case 87:
        for(var i=0;i<wall.length;i++){
          if ((hero.y-30>0) && ((hero.y+30 - hero.speed)>= wall[i].y) &&(hero.y+30 - hero.speed) < (wall[i].y + 40) && (hero.x+20 >= wall[i].x) &&( hero.x < wall[i].x + 40)&&(wall[i].isLive==true)){
            flag = 1;
          }
        }
        if((hero.y-hero.speed)>0&&flag!=1){
          hero.moveUp();
        }
        break;
      case 74:
        hero.shotEnermy();
        break;
    }
//写一个函数，专门用于定时刷新画布
    flashTanMap();
  }
  var timer1=setInterval("flashTanMap()",100);
var timer=setInterval("flashBullet()",100);




</script>

</body>
</html>